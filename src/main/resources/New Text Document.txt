---entity mới---
package com.se445g.SE_445_G_ETL.entity.staging;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "stg_task_performance")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class STG_TaskPerformance {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long taskId;

    private Long employeePerformanceId;

    private String taskName;

    private Integer taskScore;

    private String note;
}
package com.se445g.SE_445_G_ETL.entity.staging;

import java.time.LocalDateTime;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "stg_employee_performance")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class STG_EmployeePerformance {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private Long employeeId;

    private Long reviewId;

    private Integer performanceScore;

    private String comments;

    private LocalDateTime createdAt;
}
package com.se445g.SE_445_G_ETL.entity.staging;

import java.time.LocalDate;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "stg_performance_review")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class STG_PerformanceReview {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long reviewId;

    private String period;

    private LocalDate startDate;

    private LocalDate endDate;

    private String description;
}
package com.se445g.SE_445_G_ETL.entity.staging;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "stg_department_performance")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class STG_DepartmentPerformance {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long deptPerfId;

    private Long departmentId;

    private Long reviewId;

    private Double averageScore;

    private String ranking;

    private String remarks;

}
package com.se445g.SE_445_G_ETL.entity.staging;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "stg_kpi_metrics")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class STG_KpiMetrics {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long kpiId;

    private String kpiName;

    private String description;

    private Double weight;

    private String category;
}

---entity mới---

---rabbitmq config---
package com.se445g.SE_445_G_ETL.config;

import org.springframework.amqp.core.*;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitMQConfig {

    // Tên queue, exchange, routing key
    public static final String EXCHANGE_NAME = "etl_exchange";

    //employees
    public static final String EMPLOYEES_QUEUE = "employees_queue";
    public static final String EMPLOYEES_ROUTING_KEY = "employees_routing_key";
    
    //performance
    public static final String PERFORMANCE_QUEUE = "performance_queue";
    public static final String PERFORMANCE_ROUTING_KEY = "performance_routing_key";

    @Bean
    public TopicExchange exchange() {
        return new TopicExchange(EXCHANGE_NAME);
    }

    @Bean
    public Queue employeesQueue() {
        return new Queue(EMPLOYEES_QUEUE, true);
    }
    
    @Bean
    public Queue performanceQueue() {
        return new Queue(PERFORMANCE_QUEUE, true);
    }

    @Bean
    public Binding employeesBinding(Queue employeesQueue, TopicExchange exchange) {
        return BindingBuilder.bind(employeesQueue).to(exchange).with(EMPLOYEES_ROUTING_KEY);
    }
    
    @Bean
    public Binding performanceBinding(Queue performanceQueue, TopicExchange exchange) {
        return BindingBuilder.bind(performanceQueue).to(exchange).with(PERFORMANCE_ROUTING_KEY);
    }

    @Bean
    public Jackson2JsonMessageConverter jsonMessageConverter() {
        return new Jackson2JsonMessageConverter();
    }

    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate template = new RabbitTemplate(connectionFactory);
        template.setMessageConverter(jsonMessageConverter());
        return template; 
    }
}
---fatDTO mới---


đọc toàn bộ entity ở trên rồi tạo ra fatDTO, mapper với mapstruct sau đó chỉnh sửa lại producer và consumer sau
---producer cũ---
package com.se445g.SE_445_G_ETL.service.impl;

import java.time.LocalDateTime;

import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Service;

import com.se445g.SE_445_G_ETL.config.RabbitMQConfig;
import com.se445g.SE_445_G_ETL.dto.PerformanceDTO;
import com.se445g.SE_445_G_ETL.service.interf.MySQLProducerService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class MySQLProducerServiceImpl implements MySQLProducerService {

    // JdbcTemplate để đọc từ MySQL nguồn (Source)
    private final JdbcTemplate jdbcTemplate;

    // RabbitTemplate để gửi đến RabbitMQ
    private final RabbitTemplate rabbitTemplate;

    // Định nghĩa các hằng số cho recordType
    private static final String TYPE_EMP = "EMPLOYEEPERFORMANCE";
    private static final String TYPE_REVIEW = "REVIEW";
    private static final String TYPE_TASK = "TASKPERFORMANCE";

    @Override
    public void sendMySQLData() {
        log.info("Bắt đầu quá trình gửi dữ liệu Performance từ MySQL...");

        // Chạy 3 quy trình độc lập, TẤT CẢ gửi về 1 queue
        sendReview();
        sendEmployeePerformance();
        sendTaskPerformance();

        log.info("Đã gửi tất cả dữ liệu Performance lên RabbitMQ.");
    }

    /**
     * Đọc từ bảng 'task_performance' và gửi DTO loại
     * TASKPERFORMANCE
     */
    private void sendTaskPerformance() {
        // Giả định 'id' trong DTO sẽ mang employee_performance_id
        String sql = "SELECT task_id, employee_performance_id, task_name, task_score, note FROM task_performance";

        RowMapper<PerformanceDTO> rowMapper = (rs, rowNum) -> PerformanceDTO.builder()
                .recordType(TYPE_TASK)
                .id(rs.getInt("employee_performance_id")) // ** QUAN TRỌNG: Gửi ID của cha (EmployeePerformance)
                .taskId(rs.getInt("task_id")) // Gửi ID của chính nó
                .taskName(rs.getString("task_name"))
                .taskScore(rs.getBigDecimal("task_score"))
                .taskNote(rs.getString("note"))
                .build();

        jdbcTemplate.query(sql, rowMapper).forEach(this::sendToQueue);
        log.info("Đã gửi dữ liệu TaskPerformances.");
    }

    /**
     * Đọc từ bảng 'performance_review' và gửi DTO loại REVIEW
     */
    private void sendReview() {
        String sql = "SELECT review_id, period, start_date, end_date, description FROM performance_review";

        RowMapper<PerformanceDTO> rowMapper = (rs, rowNum) -> PerformanceDTO.builder()
                .recordType(TYPE_REVIEW)
                .reviewId(rs.getInt("review_id"))
                .period(rs.getString("period"))
                .startDate(rs.getDate("start_date").toLocalDate())
                .endDate(rs.getDate("end_date").toLocalDate())
                .reviewDescription(rs.getString("description"))
                .build();

        jdbcTemplate.query(sql, rowMapper).forEach(this::sendToQueue);
        log.info("Đã gửi dữ liệu Reviews.");
    }

    /**
     * Đọc từ bảng 'employee_performance' và gửi DTO loại
     * EMPLOYEEPERFORMANCE
     */
    private void sendEmployeePerformance() {
        String sql = "SELECT id, employee_id, review_id, performance_score, comments, created_at FROM employee_performance";

        RowMapper<PerformanceDTO> rowMapper = (rs, rowNum) -> PerformanceDTO.builder()
                .recordType(TYPE_EMP)
                .id(rs.getInt("id"))
                .employeeId(rs.getInt("employee_id"))
                .reviewId(rs.getInt("review_id")) // Gửi khóa ngoại
                .performanceScore(rs.getBigDecimal("performance_score"))
                .comments(rs.getString("comments"))
                .createdAt(rs.getTimestamp("created_at") != null ? rs.getTimestamp("created_at").toLocalDateTime()
                        : LocalDateTime.now())
                .build();

        jdbcTemplate.query(sql, rowMapper).forEach(this::sendToQueue);
        log.info("Đã gửi dữ liệu EmployeePerformances.");
    }

    /**
     * Phương thức chung để gửi DTO đến 1 queue duy nhất
     */
    private void sendToQueue(PerformanceDTO dto) {
        rabbitTemplate.convertAndSend(
                RabbitMQConfig.EXCHANGE_NAME,
                RabbitMQConfig.PERFORMANCE_ROUTING_KEY,
                dto);
    }
}

---consumer cũ---
package com.se445g.SE_445_G_ETL.service.impl;

import java.time.LocalDateTime;

import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.se445g.SE_445_G_ETL.config.RabbitMQConfig;
import com.se445g.SE_445_G_ETL.dto.EmployeeDTO;
import com.se445g.SE_445_G_ETL.dto.PerformanceDTO;
import com.se445g.SE_445_G_ETL.entity.staging.STG_Department;
import com.se445g.SE_445_G_ETL.entity.staging.STG_Employee;
import com.se445g.SE_445_G_ETL.entity.staging.STG_EmployeePerformance;
import com.se445g.SE_445_G_ETL.entity.staging.STG_PerformanceReview;
import com.se445g.SE_445_G_ETL.entity.staging.STG_Salary;
import com.se445g.SE_445_G_ETL.entity.staging.STG_TaskPerformance;
import com.se445g.SE_445_G_ETL.repository.staging.STG_DepartmentRepository;
import com.se445g.SE_445_G_ETL.repository.staging.STG_EmployeePerformanceRepository;
import com.se445g.SE_445_G_ETL.repository.staging.STG_EmployeeRepository;
import com.se445g.SE_445_G_ETL.repository.staging.STG_PerformanceReviewRepository;
import com.se445g.SE_445_G_ETL.repository.staging.STG_SalaryRepository;
import com.se445g.SE_445_G_ETL.repository.staging.STG_TaskPerformanceRepository;
import com.se445g.SE_445_G_ETL.service.interf.ConsumerService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class ConsumerServiceImpl implements ConsumerService {
    
    private final STG_PerformanceReviewRepository reviewRepository;
    private final STG_EmployeePerformanceRepository employeePerformanceRepository;
    private final STG_TaskPerformanceRepository taskPerformanceRepository;

    /**
     * Một Listener duy nhất lắng nghe PERFORMANCE_QUEUE
     */
    @RabbitListener(queues = RabbitMQConfig.PERFORMANCE_QUEUE)
    @Transactional // Đảm bảo mỗi tin nhắn được xử lý như 1 giao dịch
    public void receiveMySQLData(PerformanceDTO dto) {
        
        String type = dto.getRecordType();
        if (type == null) {
            log.warn("Đã nhận message không có recordType: {}", dto);
            return;
        }

        try {
            switch (type) {
                case "REVIEW":
                    processReview(dto);
                    break;
                case "EMPLOYEEPERFORMANCE":
                    processEmployeePerformance(dto);
                    break;
                case "TASKPERFORMANCE":
                    processTaskPerformance(dto);
                    break;
                default:
                    log.warn("Không nhận diện được recordType: '{}'", type);
            }
        } catch (Exception e) {
            // === THÊM LOGGING CHI TIẾT VÀO ĐÂY ===
            String parentId = (type.equals("TASKPERFORMANCE")) ? String.valueOf(dto.getId()) : "N/A";
            String childId = (type.equals("TASKPERFORMANCE")) ? String.valueOf(dto.getTaskId())
                    : String.valueOf(dto.getId());

            log.error("LỖI XỬ LÝ ETL (Type: {}). ParentID: {}, ChildID: {}. DTO: {}. Lỗi: {}",
                    type,
                    parentId,
                    childId,
                    dto.toString(),
                    e.getMessage());
            // Chúng ta không ném lại lỗi để tránh message bị requeue (vòng lặp lỗi)
            // Thay vào đó, message này sẽ được "ack" (coi như đã xử lý)
            // Bạn có thể thiết lập Dead Letter Queue (DLQ) để giữ lại các message lỗi này
        }
    }

    /**
     * Xử lý lưu STG_PerformanceReview
     */
    private void processReview(PerformanceDTO dto) {
        log.info("Processing REVIEW: {}", dto.getReviewId());
        STG_PerformanceReview review = STG_PerformanceReview.builder()
                .reviewId(dto.getReviewId())
                .period(dto.getPeriod())
                .startDate(dto.getStartDate())
                .endDate(dto.getEndDate())
                .description(dto.getReviewDescription())
                .build();
        // Dùng save() cho logic "Upsert" (Update nếu ID tồn tại, Insert nếu chưa)
        reviewRepository.save(review);
    }

    /**
     * Xử lý lưu STG_EmployeePerformance
     */
    private void processEmployeePerformance(PerformanceDTO dto) {
        log.info("Processing EMPLOYEEPERFORMANCE: {}", dto.getId());

        // 1. Tạo proxy cho Review (để set khóa ngoại)
        STG_PerformanceReview reviewProxy = new STG_PerformanceReview();
        reviewProxy.setReviewId(dto.getReviewId());

        // 2. Build đối tượng chính
        STG_EmployeePerformance empPerf = STG_EmployeePerformance.builder()
                .id(dto.getId())
                .employeeId(dto.getEmployeeId())
                .review(reviewProxy) // Gán proxy
                .performanceScore(dto.getPerformanceScore())
                .comments(dto.getComments())
                .createdAt(dto.getCreatedAt() != null ? dto.getCreatedAt() : LocalDateTime.now())
                .build();
        
        // 3. Dùng save() cho logic "Upsert"
        employeePerformanceRepository.save(empPerf);
    }

    /**
     * Xử lý lưu STG_TaskPerformance
     */
    private void processTaskPerformance(PerformanceDTO dto) {
        log.info("Processing TASKPERFORMANCE: {}", dto.getTaskId());

        // 1. Tạo proxy cho EmployeePerformance (để set khóa ngoại)
        // Dựa trên logic của Producer, dto.getId() đang giữ employee_performance_id
        STG_EmployeePerformance empPerfProxy = new STG_EmployeePerformance();
        empPerfProxy.setId(dto.getId()); 

        // 2. Build đối tượng chính
        STG_TaskPerformance taskPerf = STG_TaskPerformance.builder()
                .taskId(dto.getTaskId())
                .employeePerformance(empPerfProxy) // Gán proxy
                .taskName(dto.getTaskName())
                .taskScore(dto.getTaskScore())
                .note(dto.getTaskNote())
                .build();

        // 3. Dùng save() cho logic "Upsert"
        taskPerformanceRepository.save(taskPerf);
    }

}

